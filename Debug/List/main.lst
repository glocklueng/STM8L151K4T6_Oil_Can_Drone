###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 14/Jan/2017  16:15:46
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\APP\main.c
#    Command line =  
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\APP\main.c"
#        -e -Ol --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model medium --data_model medium -o
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\"
#        --dlib_config "E:\My Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D
#        STM8L15X_MD -lcN
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\Debug\List\"
#        -I "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\"
#        -I
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\inc\"
#        -I
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\APP\"
#        -I
#        "C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\BSP\"
#        --vregs 16
#    List file    =  
#        C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\Debug\List\main.lst
#    Object file  =  
#        C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\main.o
#
###############################################################################

C:\Users\Growl\Desktop\Can_New(+1B)\STM8L151K4T6_Oil_Can_Drone\APP\main.c
      1          #include "stdio.h" 
      2          #include "string.h" 
      3          #include "bsp.h" 
      4          #include "CC1101.h"
      5          
      6          // USART_CSB
      7          #define Dis_Len 2
      8          volatile u8 Distance[Dis_Len] = {0, 0};
      9          volatile u8 Dis_Index = 0;
     10          volatile u8 distance = 0; 
     11          
     12          // CC1101
     13          volatile u16  Cnt1ms = 0;     // 1ms计数变量，每1ms加一 
     14          int  RecvWaitTime = 0;        // 接收等待时间                
     15          u16  SendCnt = 0;             // 计数发送的数据包数                
     16          
     17                                     // 帧头  源地址  目标地址  distance*10  电池电量 帧尾
     18          u8 SendBuffer[SEND_LENGTH] = {0x55,   0,    0xff,     15,         50,      0xaa}; // 从机待发送数据
     19                                     // 帧头  源地址  目标地址  帧尾
     20          u8 AckBuffer[ACK_LENGTH]   = {0x55,  0xff,     0,     0xaa};        // 主机应答数据
     21                       
     22          void System_Initial(void);                     // 系统初始化
     23          u8   RF_SendPacket(u8 *Sendbuffer, u8 length);  // 从机发送数据包
     24          void Get_TheTime(void);
     25          void RTC_AWU_Initial(uint16_t time);            // time * 26.95 ms 
     26          void DelayMs(u16 x);                            // TIM3延时函数
     27          u8   Measured_Range(void);                      // 超声波测距
     28          
     29          // printf支持
     30          int putchar(int c)   
     31          {  
     32              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
     33              USART_SendData8(USART1, (uint8_t)c);
     34              return (c);  
     35          }
     36          
     37          void main(void)
     38          {
     39              u8 i = 0, SendError_Time = 0;                      // 连续发送出错次数
     40              volatile u8 res = 0;
     41              volatile u8 Timer_30s = 6;                        // 上电发送
     42              float ADC_Value = 0.0f;
     43              SendBuffer[1] = TX_Address;                       // 数据包源地址（从机地址）
     44                 
     45              System_Initial();                                 // 初始化系统所有外设              	
     46              
     47              // 综合测试
     48              while(1)
     49              {
     50                  printf("Timer_30s=%d\r\n", (int)Timer_30s);  
     51                  if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
     52                  {
     53                      // ADC采集电池电压
     54                      ADC_Value = 0;
     55                      for(i = 0; i < 4; i++) ADC_Value += ADC_Data_Read();                  // PA4
     56                      ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer / 4.0;
     57                      printf("ADC_Value = %.2f V\r\n", ADC_Value); 
     58                      //SendBuffer[4] = ((u8)((ADC_Value * 300.0) / Voltage_Bat_Full) ) % 101;   // 限定电量百分比在[0,100]      ADC 1/3分压
     59                      SendBuffer[4] = ((u8)(((ADC_Value * 3.0 - Voltage_Bat_Empty) / (Voltage_Bat_Full - Voltage_Bat_Empty)) * 100)) % 101;   // 限定电量百分比在[0,100]      ADC 1/3分压
     60                      
     61                      SWITCH_ON();                       // 接通CC1101、CSB电源
     62                      LED_ON();                          // LED闪烁，用于指示发送成功
     63                      //CSB_Initial();                     // 初始化超声波模块
     64                      CC1101Init();                      // 初始化CC1101为发送模式 
     65                      SendError_Time = 0;                // 出错次数清零
     66                      
     67                      distance = Measured_Range();       // 测距 
     68                      if(distance)  
     69                      {
     70                          SendBuffer[3] = distance;
     71                          printf("distance = %d cm\r\n", distance);
     72                      }
     73                      else 
     74                      {
     75                          SendBuffer[3] = 255;
     76                          printf("Measured_Error\r\n");
     77                      } 
     78                      
     79          //*******************************************************************************************
     80          send:            
     81                      res = RF_SendPacket(SendBuffer, SEND_LENGTH);
     82                      if(res != 0) 
     83                      {
     84                          printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
     85                          DelayMs(5);
     86                          if(++SendError_Time < 20) goto send;   //  出错次数达到20次，则放弃此次传输
     87                          printf("Send Canceled!\r\n");  // 发送失败
     88                      }
     89                      else 
     90                      {
     91                          for(i = 0; i < SEND_LENGTH; i++) printf("%d ", SendBuffer[i]);
     92                          printf("Send OK!\r\n");              // 发送成功
     93                      }
     94          //*******************************************************************************************     
     95                      
     96                      SWITCH_OFF();                      // 关闭CC1101、CSB电源
     97                      LED_OFF();
     98                      Timer_30s = 6;                     // 1
     99                  }
    100                  RTC_AWU_Initial(1116);                 // RTC 唤醒中断    30s
    101                  halt();                                // 挂起，最低功耗
    102              }
    103          }
    104          
    105          /*===========================================================================
    106          * 函数 : DelayMs() => 延时函数(ms级)                                        *
    107          * 输入 ：x, 需要延时多少(0-65535)                                             *
    108          ============================================================================*/
    109          void DelayMs(u16 x)
    110          {
    111              u16 timer_ms = x;
    112              
    113              Cnt1ms = 0;
    114              TIM3_Set(1);
    115              while(Cnt1ms < timer_ms);
    116              TIM3_Set(0);
    117          }
    118          
    119          /*===========================================================================
    120          * 函数 ：TIM3_1MS_ISR() => 定时器3服务函数, 定时时间基准为1ms               *
    121          ============================================================================*/
    122          void TIM3_1MS_ISR(void)
    123          {
    124              Cnt1ms++;
    125              if(RecvWaitTime > 0) RecvWaitTime--;    // 数据接收计时
    126          }
    127          
    128          /*===========================================================================
    129          * 函数: System_Initial() => 初始化系统所有外设                              *
    130          ============================================================================*/
    131          void System_Initial(void)
    132          {
    133              SClK_Initial();         // 初始化系统时钟，16M / 4 = 4M    
    134              GPIO_Initial();         // 初始化GPIO   LED  SWITCH
    135           
    136              USART1_Initial();       // 初始化串口1  超声波模块使用 
    137              TIM3_Initial();         // 初始化定时器3，基准1ms  
    138              SPI_Initial();          // 初始化SPI  
    139              ADC_Initial();          // 初始化ADC
    140              
    141              //CSB_Initial();          // 初始化超声波模块
    142             
    143              enableInterrupts();     // 使能系统总中断
    144              
    145              printf("Oil_Can_Drone\r\n");                      // 发送字符串，末尾换行
    146          }
    147          
    148          /*===========================================================================
    149          * 函数 : BSP_RF_SendPacket() => 无线发送数据函数                            *
    150          * 输入 ：Sendbuffer指向待发送的数据，length发送数据长度                      *
    151          * 输出 ：0，发送成功                                                      
    152                   1，等待应答超时
    153                   2，数据包长度错误
    154                   3，数据包帧头错误
    155                   4，数据包源地址错误
    156                   5，数据包目标地址错误
    157                   6，数据包帧尾
    158                   7，应答信号错误
    159          ============================================================================*/
    160          INT8U RF_SendPacket(INT8U *Sendbuffer, INT8U length)
    161          {
    162              uint8_t  i = 0, ack_len = 0, ack_buffer[10] = {0};
    163              RecvWaitTime = (int)RECV_TIMEOUT;           // 等待应答超时限制1500ms
    164              
    165              CC1101SendPacket(SendBuffer, length, ADDRESS_CHECK);    // 发送数据 
    166              CC1101SetTRMode(RX_MODE);                               // 准备接收应答
    167          
    168              TIM3_Set(1);                                // 开启TIM3
    169              //printf("waiting for ack...\r\n");
    170              while(CC_IRQ_READ() != 0)                   // 等待接收数据包
    171              {
    172                  if(RecvWaitTime <= 0)      
    173                  {  
    174                      TIM3_Set(0);                            // 关闭TIM3
    175                      return 1;                              // 等待应答超时
    176                  }
    177              }
    178              RecvWaitTime = 50;           // 等待应答超时限制50ms
    179              while(CC_IRQ_READ() == 0)
    180              {
    181                  if(RecvWaitTime <= 0)      
    182                  {  
    183                      TIM3_Set(0);                            // 关闭TIM3
    184                      return 7;                              // 等待应答超时
    185                  }
    186              }
    187          //    printf("RecvWaitTime2=%d\r\n", RecvWaitTime);
    188              TIM3_Set(0);                                // 关闭TIM3
    189              ack_len = CC1101RecPacket(ack_buffer);      // 读取收到的数据
    190              
    191              if(ack_len <= 0 || ack_len > 10)  
    192              {
    193                  CC1101Init(); 
    194                  //printf("ack_len1=%d\r\n", ack_len);
    195                  return 2;                                          // 数据包长度错误
    196              }
    197              if(ack_len != ACK_LENGTH) return 2;                    // 数据包长度错误
    198              if(ack_buffer[0] != 0x55) return 3;                    // 数据包帧头错误
    199              if(ack_buffer[1] != 0xff) return 4;                    // 数据包源地址错误       
    200              if(ack_buffer[2] != TX_Address) return 5;              // 数据包目标地址错误
    201              if(ack_buffer[3] != 0xaa) return 6;            // 数据包帧尾
    202          
    203              // 应答正确
    204              printf("ack_len=%d;ack_buffer:", (int)ack_len);
    205              for(i = 0; i < ack_len; i++)                     
    206              {
    207                  printf("%d ", (int)ack_buffer[i]);
    208              }
    209              printf("\r\n");
    210          
    211              return 0;  
    212          }
    213          
    214          void Get_TheTime(void)
    215          {
    216            RTC_TimeTypeDef GETRTC_Time;
    217            RTC_DateTypeDef GETRTC_Data;
    218            //unsigned char sec_st,sec_su , min_mt,min_mu ,hour_ht , hour_hu , midd ,status;
    219            if(RTC_GetFlagStatus(RTC_FLAG_RSF) == SET)  //有时间更新 
    220            {
    221              RTC_GetDate(RTC_Format_BIN , &GETRTC_Data);
    222              RTC_GetTime(RTC_Format_BIN , &GETRTC_Time);  
    223                
    224               RTC_ClearFlag(RTC_FLAG_RSF);   //清除标志
    225               printf("20%d/%d/%d Day%d %d:%d:%d\r\n", GETRTC_Data.RTC_Year, GETRTC_Data.RTC_Month, GETRTC_Data.RTC_Date, GETRTC_Data.RTC_WeekDay, GETRTC_Time.RTC_Hours, GETRTC_Time.RTC_Minutes, GETRTC_Time.RTC_Seconds);
    226            }
    227          }
    228          
    229          // 外部时钟32K
    230          void RTC_AWU_Initial(uint16_t time)    // time * 32 ms 
    231          { 
    232              RTC_DeInit();   // 初始化默认状态 
    233           
    234          #if RTC_CLK == RTC_CLK_LSE   // 外部32K时钟
    235              CLK_LSEConfig(CLK_LSE_ON);  
    236              while (CLK_GetFlagStatus(CLK_FLAG_LSERDY) == RESET);  
    237              CLK_RTCClockConfig(CLK_RTCCLKSource_LSE, CLK_RTCCLKDiv_64);  // 选择RTC时钟源LSE/64=500Hz 
    238              
    239          #else                        // 内部38K时钟
    240              CLK_RTCClockConfig(CLK_RTCCLKSource_LSI, CLK_RTCCLKDiv_64);  // 选择RTC时钟源LSI/64=593.75Hz 
    241           
    242          #endif 
    243              
    244              CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE);      // 允许RTC时钟 
    245              RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);        // 500Hz/16=31.25Hz t = 32ms 
    246              RTC_ITConfig(RTC_IT_WUT, ENABLE);  // 开启中断 
    247              RTC_SetWakeUpCounter(time);        // 设置RTC Weakup计算器初值 
    248              RTC_WakeUpCmd(ENABLE);             // 使能自动唤醒 
    249          } 
    250          
    251          
    252          // 返回距离   0~255  cm
    253          // 0:测量出错
    254          u8 Measured_Range(void)
    255          {
    256              u8 distance_cm = 0, error_timer = 0, threshold_timer = 0;
    257              
    258          Detectde:
    259              CSB_Sleep();
    260              distance_cm = 0;
    261              Distance[0] = 0;    // 清零，重新测距
    262              Distance[1] = 0;    
    263              Dis_Index = 0;
    264              CSB_Wakeup();
    265              //DelayMs(1);       // 至少50us 唤醒
    266              
    267              DelayMs(5);         // 系统唤醒3ms后，发送测距触发信号0x55  
    268              
    269              //U1_Set(1);        // 开启U1接收中断，准备接收测量结果
    270              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
    271              USART_SendData8(USART1, 0x55); 
    272              
    273              DelayMs(20);      // 等待串口返回测量结果   25
    274              CSB_Sleep(); 
    275              //U1_Set(0);        // 关闭串口1
    276              
    277              if(Dis_Index == Dis_Len) // 串口收到距离信息
    278              {
    279                  distance_cm = ( (( (u16)Distance[0] << 8 ) + Distance[1]) / 10 ) & 0xff;    // 限定distance_cm在[0, 255]范围内
    280                  if(distance_cm <= 11)      // 测距出错
    281                  {
    282                      if(++threshold_timer == 100) 
    283                      {
    284                          printf("Threshold ERROR\r\n");
    285                          return 0;     // 测距出错，返回0
    286                      }
    287                      DelayMs(15);
    288                      goto Detectde;
    289                  }
    290                  else return distance_cm;  // 测距正确 
    291              }
    292              else
    293              {
    294                  if(++error_timer == 10) 
    295                  {
    296                      printf("Timer_10 ERROR\r\n");
    297                      return 0;           // 测距出错，返回0
    298                  }
    299                  DelayMs(15);
    300                  goto Detectde;
    301              }
    302          }
    303          
    304          //// RTC-AWU测试
    305          //    while(1)
    306          //    {
    307          //        LED_TOG();                // LED闪烁，用于指示发送成功
    308          //        printf("OK!\r\n");            
    309          //        RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
    310          //        halt();//挂起，最低功耗
    311          //    }
    312          
    313          //    // CSB测试
    314          //    while(1)
    315          //    {
    316          //        SWITCH_ON();                       // 接通CC1101、CSB电源
    317          //        //CSB_Initial();                     // 初始化超声波模块
    318          //        CC1101Init();                      // 初始化CC1101为发送模式 
    319          //        distance = Measured_Range();       // 测距 
    320          //        if(distance)  
    321          //        {
    322          //            LED_ON();
    323          //            printf("distance = %d cm\r\n", distance);
    324          //        }
    325          //        else 
    326          //        {
    327          //            LED_OFF();
    328          //            printf("Measured_Error\r\n");
    329          //        } 
    330          //        SWITCH_OFF();                      // 关闭CC1101、CSB电源
    331          //        RTC_AWU_Initial(2232);             // RTC 唤醒中断    60s
    332          //        halt();                            // 挂起，最低功耗
    333          ////        DelayMs(1500); 
    334          ////        DelayMs(1500); 
    335          //    }
    336              
    337          // // ADC测试 
    338          //    while(1)
    339          //    {
    340          //        ADC_Value = 0;
    341          //        for(i = 0; i < 4; i++) ADC_Value += ADC_Data_Read();                  // PA4
    342          //        ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer / 4.0;
    343          //        printf("ADC_Value = %.2f V\r\n", ADC_Value); 
    344          //        DelayMs(1000);DelayMs(1000);
    345          //    }
    346          
    347          ////  RTC测试 
    348          //    RTC_Initial();            // 初始化RTC   LSI
    349          //    while(1)
    350          //    {
    351          //        Get_TheTime();
    352          //        DelayMs(1000);DelayMs(1000);
    353          //    }
    354              
    355          ///// 通信测试
    356          //    CC1101Init();                          // 初始化CC1101模块
    357          //    while(1)
    358          //    {
    359          //        LED_ON();                          // LED闪烁，用于指示发送成功
    360          // send:        
    361          //        res = RF_SendPacket(SendBuffer, SEND_LENGTH);
    362          //        if(res != 0) 
    363          //        {
    364          //          printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
    365          //          DelayMs(25);
    366          //          goto send;
    367          //        }
    368          //        else  printf("Send OK!\r\n");              // 发送成功
    369          //        LED_OFF();
    370          //        
    371          //        DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);
    372          //    }
    373          
    374          //    while(1)
    375          //    {
    376          //        printf("Timer_30s=%d\r\n", (int)Timer_30s);  
    377          //        if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
    378          //        {
    379          //            // ADC采集
    380          //            ADC_Value = ADC_Data_Read();                  // PA4
    381          //            ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer;
    382          //            printf("ADC_Value = %.2f V\r\n", ADC_Value); 
    383          //          
    384          //            SWITCH_ON();                       // 接通CC1101、CSB电源
    385          //            LED_ON();                          // LED闪烁，用于指示发送成功
    386          //            //CSB_Initial();                     // 初始化超声波模块
    387          //            CC1101Init();                      // 初始化CC1101模块
    388          //            SendError_Time = 0;                // 出错次数清零
    389          //              
    390          //            distance = Measured_Range();       // 超声波测距 
    391          //            if(distance)  
    392          //            {
    393          //                SendBuffer[3] = distance;
    394          //                printf("distance = %d cm\r\n", distance);
    395          //            }
    396          //            else 
    397          //            {
    398          //                SendBuffer[3] = 0;             // 测量出错  发送0
    399          //                printf("Measured_Error\r\n");
    400          //            } 
    401          //send:            
    402          //            res = RF_SendPacket(SendBuffer, SEND_LENGTH);
    403          //            if(res != 0) 
    404          //            {
    405          //                printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
    406          //                DelayMs(25);
    407          //                if(++SendError_Time < 20) goto send;   //  出错次数达到20次，则放弃此次传输
    408          //                printf("Send Canceled!\r\n");  // 发送失败
    409          //            }
    410          //            else printf("Send OK!\r\n");              // 发送成功
    411          //            
    412          //            SWITCH_OFF();
    413          //            LED_OFF();
    414          //            Timer_30s = 5;    // 1
    415          //        }
    416          //        RTC_AWU_Initial(1116);     // RTC 唤醒中断    1116 * 26.95 ms = 30s
    417          //        halt();//挂起，最低功耗
    418          //    }

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?_0
      21  ?_1
      23  ?_10
       3  ?_11
      28  ?_12
      18  ?_13
      17  ?_14
      19  ?_2
      17  ?_3
      16  ?_4
      17  ?_5
       4  ?_6
      11  ?_7
      16  ?_8
      10  ?_9
       4  AckBuffer
       2  Cnt1ms
      32  DelayMs
       1  Dis_Index
       2  Distance
      85  Get_TheTime
     215  Measured_Range
     285  RF_SendPacket
      60  RTC_AWU_Initial
       2  RecvWaitTime
       6  SendBuffer
       2  SendCnt
      32  System_Initial
      23  TIM3_1MS_ISR
       1  distance
     427  main
      36  putchar

 
 1 195 bytes in section .far_func.text
    10 bytes in section .near.bss
    10 bytes in section .near.data
   235 bytes in section .near.rodata
 
 1 195 bytes of CODE  memory
   235 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: 1
