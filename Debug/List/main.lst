###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 11/Jan/2017  15:15:13
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\main.c
#    Command line =  
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\main.c" -e -Ol
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model medium --data_model medium -o
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\"
#        --dlib_config "E:\My Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D
#        STM8L15X_MD -lcN "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\inc\" -I
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\BSP\" --vregs 16
#    List file    =  
#        E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\main.lst
#    Object file  =  
#        E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\main.o
#
###############################################################################

E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\main.c
      1          #include "stdio.h" 
      2          #include "string.h" 
      3          #include "bsp.h" 
      4          #include "CC1101.h"
      5          
      6          // USART_CSB
      7          #define Dis_Len 2
      8          volatile u8 Distance[Dis_Len] = {0, 0};
      9          volatile u8 Dis_Index = 0;
     10          volatile u8 distance = 0; 
     11          
     12          // CC1101
     13          volatile u16  Cnt1ms = 0;     // 1ms计数变量，每1ms加一 
     14          int  RecvWaitTime = 0;        // 接收等待时间                
     15          u16  SendCnt = 0;             // 计数发送的数据包数                
     16          
     17                                     // 帧头  源地址  目标地址  distance*10  帧尾
     18          u8 SendBuffer[SEND_LENGTH] = {0x55,   0,    0xff,     15,          0xaa}; // 从机待发送数据
     19                                     // 帧头  源地址  目标地址  帧尾
     20          u8 AckBuffer[ACK_LENGTH]   = {0x55,  0xff,     0,     0xaa};        // 主机应答数据
     21                       
     22          void System_Initial(void);                     // 系统初始化
     23          u8   RF_SendPacket(u8 *Sendbuffer, u8 length);  // 从机发送数据包
     24          void Get_TheTime(void);
     25          void RTC_AWU_Initial(uint16_t time);            // time * 26.95 ms 
     26          void DelayMs(u16 x);                            // TIM3延时函数
     27          u8   Measured_Range(void);                      // 超声波测距
     28          
     29          // printf支持
     30          int putchar(int c)   
     31          {  
     32              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
     33              USART_SendData8(USART1, (uint8_t)c);
     34              return (c);  
     35          }
     36          
     37          void main(void)
     38          {
     39              u8 i = 0, SendError_Time = 0;                             // 连续发送出错次数
     40              volatile u8 res = 0;
     41              volatile u8 Timer_30s = 6;  
     42              // 上电发送
     43              float ADC_Value = 0.0f;
     44              SendBuffer[1] = TX_Address;                       // 数据包源地址（从机地址）
     45                 
     46              System_Initial();                                 // 初始化系统所有外设              	
     47              
     48              // 综合测试
     49              while(1)
     50              {
     51                  printf("Timer_30s=%d\r\n", (int)Timer_30s);  
     52                  if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
     53                  {
     54                      // ADC采集电池电压
     55                      ADC_Value = 0;
     56                      for(i = 0; i < 4; i++) ADC_Value += ADC_Data_Read();                  // PA4
     57                      ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer / 4.0;
     58                      printf("ADC_Value = %.2f V\r\n", ADC_Value); 
     59                  
     60                      SWITCH_ON();                       // 接通CC1101、CSB电源
     61                      LED_ON();                          // LED闪烁，用于指示发送成功
     62                      //CSB_Initial();                     // 初始化超声波模块
     63                      CC1101Init();                      // 初始化CC1101为发送模式 
     64                      SendError_Time = 0;                // 出错次数清零
     65                      
     66                      distance = Measured_Range();       // 测距 
     67                      if(distance)  
     68                      {
     69                          SendBuffer[3] = distance;
     70                          printf("distance = %d cm\r\n", distance);
     71                      }
     72                      else 
     73                      {
     74                          SendBuffer[3] = 255;
     75                          printf("Measured_Error\r\n");
     76                      } 
     77                      
     78          //*******************************************************************************************
     79          send:            
     80                      res = RF_SendPacket(SendBuffer, SEND_LENGTH);
     81                      if(res != 0) 
     82                      {
     83                          printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
     84                          DelayMs(25);
     85                          if(++SendError_Time < 20) goto send;   //  出错次数达到20次，则放弃此次传输
     86                          printf("Send Canceled!\r\n");  // 发送失败
     87                      }
     88                      else 
     89                      {
     90                          for(i = 0; i < SEND_LENGTH; i++) printf("%d ", SendBuffer[i]);
     91                          printf("Send OK!\r\n");              // 发送成功
     92                      }
     93          //*******************************************************************************************     
     94                      
     95                      SWITCH_OFF();                      // 关闭CC1101、CSB电源
     96                      LED_OFF();
     97                      Timer_30s = 3;                     // 1
     98                  }
     99                  RTC_AWU_Initial(1116);               // RTC 唤醒中断    30s
    100                  halt();                             // 挂起，最低功耗
    101              }
    102          }
    103          
    104          /*===========================================================================
    105          * 函数 : DelayMs() => 延时函数(ms级)                                        *
    106          * 输入 ：x, 需要延时多少(0-65535)                                             *
    107          ============================================================================*/
    108          void DelayMs(u16 x)
    109          {
    110              u16 timer_ms = x;
    111              
    112              Cnt1ms = 0;
    113              TIM3_Set(1);
    114              while(Cnt1ms < timer_ms);
    115              TIM3_Set(0);
    116          }
    117          
    118          /*===========================================================================
    119          * 函数 ：TIM3_1MS_ISR() => 定时器3服务函数, 定时时间基准为1ms               *
    120          ============================================================================*/
    121          void TIM3_1MS_ISR(void)
    122          {
    123              Cnt1ms++;
    124              if(RecvWaitTime > 0) RecvWaitTime--;    // 数据接收计时
    125          }
    126          
    127          /*===========================================================================
    128          * 函数: System_Initial() => 初始化系统所有外设                              *
    129          ============================================================================*/
    130          void System_Initial(void)
    131          {
    132              SClK_Initial();         // 初始化系统时钟，16M / 4 = 4M    
    133              GPIO_Initial();         // 初始化GPIO   LED  SWITCH
    134           
    135              USART1_Initial();       // 初始化串口1  超声波模块使用 
    136              TIM3_Initial();         // 初始化定时器3，基准1ms  
    137              SPI_Initial();          // 初始化SPI  
    138              ADC_Initial();          // 初始化ADC
    139              
    140              //CSB_Initial();          // 初始化超声波模块
    141             
    142              enableInterrupts();     // 使能系统总中断
    143              
    144              printf("Oil_Can_Drone\r\n");                      // 发送字符串，末尾换行
    145          }
    146          
    147          /*===========================================================================
    148          * 函数 : BSP_RF_SendPacket() => 无线发送数据函数                            *
    149          * 输入 ：Sendbuffer指向待发送的数据，length发送数据长度                      *
    150          * 输出 ：0，发送成功                                                      
    151                   1，等待应答超时
    152                   2，数据包长度错误
    153                   3，数据包帧头错误
    154                   4，数据包源地址错误
    155                   5，数据包目标地址错误
    156                   6，数据包帧尾
    157                   7，应答信号错误
    158          ============================================================================*/
    159          INT8U RF_SendPacket(INT8U *Sendbuffer, INT8U length)
    160          {
    161              uint8_t  i = 0, ack_len = 0, ack_buffer[10] = {0};
    162              RecvWaitTime = (int)RECV_TIMEOUT;           // 等待应答超时限制1500ms
    163              
    164              CC1101SendPacket(SendBuffer, length, ADDRESS_CHECK);    // 发送数据 
    165              CC1101SetTRMode(RX_MODE);                               // 准备接收应答
    166          
    167              TIM3_Set(1);                                // 开启TIM3
    168              //printf("waiting for ack...\r\n");
    169              while(CC_IRQ_READ() != 0)                   // 等待接收数据包
    170              {
    171                  if(RecvWaitTime <= 0)      
    172                  {  
    173                      TIM3_Set(0);                            // 关闭TIM3
    174                      return 1;                              // 等待应答超时
    175                  }
    176              }
    177              RecvWaitTime = 50;           // 等待应答超时限制50ms
    178              while(CC_IRQ_READ() == 0)
    179              {
    180                  if(RecvWaitTime <= 0)      
    181                  {  
    182                      TIM3_Set(0);                            // 关闭TIM3
    183                      return 7;                              // 等待应答超时
    184                  }
    185              }
    186          //    printf("RecvWaitTime2=%d\r\n", RecvWaitTime);
    187              TIM3_Set(0);                                // 关闭TIM3
    188              ack_len = CC1101RecPacket(ack_buffer);      // 读取收到的数据
    189              
    190              if(ack_len <= 0 || ack_len > 10)  
    191              {
    192                  CC1101Init(); 
    193                  //printf("ack_len1=%d\r\n", ack_len);
    194                  return 2;                                          // 数据包长度错误
    195              }
    196              if(ack_len != ACK_LENGTH) return 2;                    // 数据包长度错误
    197              if(ack_buffer[0] != 0x55) return 3;                    // 数据包帧头错误
    198              if(ack_buffer[1] != 0xff) return 4;                    // 数据包源地址错误       
    199              if(ack_buffer[2] == 0xff) return 5;                    // 数据包目标地址错误
    200              if(ack_buffer[3] != 0xaa) return 6;            // 数据包帧尾
    201          
    202              // 应答正确
    203              printf("ack_len=%d;ack_buffer:", (int)ack_len);
    204              for(i = 0; i < ack_len; i++)                     
    205              {
    206                  printf("%d ", (int)ack_buffer[i]);
    207              }
    208              printf("\r\n");
    209          
    210              return 0;  
    211          }
    212          
    213          void Get_TheTime(void)
    214          {
    215            RTC_TimeTypeDef GETRTC_Time;
    216            RTC_DateTypeDef GETRTC_Data;
    217            //unsigned char sec_st,sec_su , min_mt,min_mu ,hour_ht , hour_hu , midd ,status;
    218            if(RTC_GetFlagStatus(RTC_FLAG_RSF) == SET)  //有时间更新 
    219            {
    220              RTC_GetDate(RTC_Format_BIN , &GETRTC_Data);
    221              RTC_GetTime(RTC_Format_BIN , &GETRTC_Time);  
    222                
    223               RTC_ClearFlag(RTC_FLAG_RSF);   //清除标志
    224               printf("20%d/%d/%d Day%d %d:%d:%d\r\n", GETRTC_Data.RTC_Year, GETRTC_Data.RTC_Month, GETRTC_Data.RTC_Date, GETRTC_Data.RTC_WeekDay, GETRTC_Time.RTC_Hours, GETRTC_Time.RTC_Minutes, GETRTC_Time.RTC_Seconds);
    225            }
    226          }
    227          
    228          // 外部时钟32K
    229          void RTC_AWU_Initial(uint16_t time)    // time * 32 ms 
    230          { 
    231              RTC_DeInit();   // 初始化默认状态 
    232           
    233          #if RTC_CLK == RTC_CLK_LSE   // 外部32K时钟
    234              CLK_LSEConfig(CLK_LSE_ON);  
    235              while (CLK_GetFlagStatus(CLK_FLAG_LSERDY) == RESET);  
    236              CLK_RTCClockConfig(CLK_RTCCLKSource_LSE, CLK_RTCCLKDiv_64);  // 选择RTC时钟源LSE/64=500Hz 
    237              
    238          #else                        // 内部38K时钟
    239              CLK_RTCClockConfig(CLK_RTCCLKSource_LSI, CLK_RTCCLKDiv_64);  // 选择RTC时钟源LSI/64=593.75Hz 
    240           
    241          #endif 
    242              
    243              CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE);      // 允许RTC时钟 
    244              RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);        // 500Hz/16=31.25Hz t = 32ms 
    245              RTC_ITConfig(RTC_IT_WUT, ENABLE);  // 开启中断 
    246              RTC_SetWakeUpCounter(time);        // 设置RTC Weakup计算器初值 
    247              RTC_WakeUpCmd(ENABLE);             // 使能自动唤醒 
    248          } 
    249          
    250          
    251          // 返回距离   0~255  cm
    252          // 0:测量出错
    253          u8 Measured_Range(void)
    254          {
    255              u8 distance_cm = 0, error_timer = 0, threshold_timer = 0;
    256              
    257          Detectde:
    258              CSB_Sleep();
    259              distance_cm = 0;
    260              Distance[0] = 0;    // 清零，重新测距
    261              Distance[1] = 0;    
    262              Dis_Index = 0;
    263              CSB_Wakeup();
    264              //DelayMs(1);       // 至少50us 唤醒
    265              
    266              DelayMs(5);         // 系统唤醒3ms后，发送测距触发信号0x55  
    267              
    268              //U1_Set(1);        // 开启U1接收中断，准备接收测量结果
    269              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
    270              USART_SendData8(USART1, 0x55); 
    271              
    272              DelayMs(25);      // 等待串口返回测量结果   25
    273              CSB_Sleep(); 
    274              //U1_Set(0);        // 关闭串口1
    275              
    276              if(Dis_Index == Dis_Len) // 串口收到距离信息
    277              {
    278                  distance_cm = ( (( (u16)Distance[0] << 8 ) + Distance[1]) / 10 ) & 0xff;    // 限定distance_cm在[0, 255]范围内
    279                  if(distance_cm <= 11)      // 测距出错
    280                  {
    281                      if(++threshold_timer == 10) 
    282                      {
    283                          printf("Threshold ERROR\r\n");
    284                          return 0;     // 测距出错，返回0
    285                      }
    286                      goto Detectde;
    287                  }
    288                  else return distance_cm;  // 测距正确 
    289              }
    290              else
    291              {
    292                  if(++error_timer == 10) 
    293                  {
    294                      printf("Timer_10 ERROR\r\n");
    295                      return 0;           // 测距出错，返回0
    296                  }
    297                  goto Detectde;
    298              }
    299          }
    300          
    301          //// RTC-AWU测试
    302          //    while(1)
    303          //    {
    304          //        LED_TOG();                // LED闪烁，用于指示发送成功
    305          //        printf("OK!\r\n");            
    306          //        RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
    307          //        halt();//挂起，最低功耗
    308          //    }
    309          
    310          //    // CSB测试
    311          //    while(1)
    312          //    {
    313          //        SWITCH_ON();                       // 接通CC1101、CSB电源
    314          //        //CSB_Initial();                     // 初始化超声波模块
    315          //        CC1101Init();                      // 初始化CC1101为发送模式 
    316          //        distance = Measured_Range();       // 测距 
    317          //        if(distance)  
    318          //        {
    319          //            LED_ON();
    320          //            printf("distance = %d cm\r\n", distance);
    321          //        }
    322          //        else 
    323          //        {
    324          //            LED_OFF();
    325          //            printf("Measured_Error\r\n");
    326          //        } 
    327          //        SWITCH_OFF();                      // 关闭CC1101、CSB电源
    328          //        RTC_AWU_Initial(2232);             // RTC 唤醒中断    60s
    329          //        halt();                            // 挂起，最低功耗
    330          ////        DelayMs(1500); 
    331          ////        DelayMs(1500); 
    332          //    }
    333              
    334          // // ADC测试 
    335          //    while(1)
    336          //    {
    337          //        ADC_Value = 0;
    338          //        for(i = 0; i < 4; i++) ADC_Value += ADC_Data_Read();                  // PA4
    339          //        ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer / 4.0;
    340          //        printf("ADC_Value = %.2f V\r\n", ADC_Value); 
    341          //        DelayMs(1000);DelayMs(1000);
    342          //    }
    343          
    344          ////  RTC测试 
    345          //    RTC_Initial();            // 初始化RTC   LSI
    346          //    while(1)
    347          //    {
    348          //        Get_TheTime();
    349          //        DelayMs(1000);DelayMs(1000);
    350          //    }
    351              
    352          ///// 通信测试
    353          //    CC1101Init();                          // 初始化CC1101模块
    354          //    while(1)
    355          //    {
    356          //        LED_ON();                          // LED闪烁，用于指示发送成功
    357          // send:        
    358          //        res = RF_SendPacket(SendBuffer, SEND_LENGTH);
    359          //        if(res != 0) 
    360          //        {
    361          //          printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
    362          //          DelayMs(25);
    363          //          goto send;
    364          //        }
    365          //        else  printf("Send OK!\r\n");              // 发送成功
    366          //        LED_OFF();
    367          //        
    368          //        DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);
    369          //    }
    370          
    371          //    while(1)
    372          //    {
    373          //        printf("Timer_30s=%d\r\n", (int)Timer_30s);  
    374          //        if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
    375          //        {
    376          //            // ADC采集
    377          //            ADC_Value = ADC_Data_Read();                  // PA4
    378          //            ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer;
    379          //            printf("ADC_Value = %.2f V\r\n", ADC_Value); 
    380          //          
    381          //            SWITCH_ON();                       // 接通CC1101、CSB电源
    382          //            LED_ON();                          // LED闪烁，用于指示发送成功
    383          //            //CSB_Initial();                     // 初始化超声波模块
    384          //            CC1101Init();                      // 初始化CC1101模块
    385          //            SendError_Time = 0;                // 出错次数清零
    386          //              
    387          //            distance = Measured_Range();       // 超声波测距 
    388          //            if(distance)  
    389          //            {
    390          //                SendBuffer[3] = distance;
    391          //                printf("distance = %d cm\r\n", distance);
    392          //            }
    393          //            else 
    394          //            {
    395          //                SendBuffer[3] = 0;             // 测量出错  发送0
    396          //                printf("Measured_Error\r\n");
    397          //            } 
    398          //send:            
    399          //            res = RF_SendPacket(SendBuffer, SEND_LENGTH);
    400          //            if(res != 0) 
    401          //            {
    402          //                printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
    403          //                DelayMs(25);
    404          //                if(++SendError_Time < 20) goto send;   //  出错次数达到20次，则放弃此次传输
    405          //                printf("Send Canceled!\r\n");  // 发送失败
    406          //            }
    407          //            else printf("Send OK!\r\n");              // 发送成功
    408          //            
    409          //            SWITCH_OFF();
    410          //            LED_OFF();
    411          //            Timer_30s = 5;    // 1
    412          //        }
    413          //        RTC_AWU_Initial(1116);     // RTC 唤醒中断    1116 * 26.95 ms = 30s
    414          //        halt();//挂起，最低功耗
    415          //    }

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?_0
      21  ?_1
      23  ?_10
       3  ?_11
      28  ?_12
      18  ?_13
      17  ?_14
      19  ?_2
      17  ?_3
      16  ?_4
      17  ?_5
       4  ?_6
      11  ?_7
      16  ?_8
      10  ?_9
       4  AckBuffer
       2  Cnt1ms
      32  DelayMs
       1  Dis_Index
       2  Distance
      85  Get_TheTime
     199  Measured_Range
     285  RF_SendPacket
      60  RTC_AWU_Initial
       2  RecvWaitTime
       5  SendBuffer
       2  SendCnt
      32  System_Initial
      23  TIM3_1MS_ISR
       1  distance
     374  main
      36  putchar

 
 1 126 bytes in section .far_func.text
    10 bytes in section .near.bss
     9 bytes in section .near.data
   235 bytes in section .near.rodata
 
 1 126 bytes of CODE  memory
   235 bytes of CONST memory
    19 bytes of DATA  memory

Errors: none
Warnings: 1
